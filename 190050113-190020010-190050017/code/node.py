import copy

# from numpy.core.numeric import tensordot 
from block import Block
from transaction import Transaction
from event import *
# import heapq 
import numpy as np 
from random import sample
from utils import *
from block import Blockchain

from queue import pushq

class Node:
    def __init__(self, nid, speed, genesis, miningTime):
        self.nid = nid # unique id of all thr nodes 
        self.speed = speed # 1=fast, 0=slow
        self.blockchain = Blockchain(genesis)
        self.miningTime = miningTime # represent the mining power of node, mean mining time of node
        self.peer = set() # neighbours of the node
        self.txnReceived = set() # txn received till now 
        self.blockReceived = set() # blocks received till now 
        


    def __str__ (self):
        return f"[Id:{pretty(self.nid, 5)}, Balance:{pretty(self.blockchain.balance(self.nid), 10)}]"

    # to establish connection between two node
    def addPeer(self,node):
        self.peer.add(node) 

    # this function is called if a new transaction is generated by the node 
    def txnSend(self, event):
        if self.blockchain.balance(self.nid) <= 0:
            return
        
        event.txn.value = np.random.randint(1, self.blockchain.balance(self.nid)+1)
        self.txnReceived.add(event.txn)

        for a in self.peer:
            t = event.time + computeLatency(self,a,1)
            action = TxnRecv(time=t, sender=self, receiver=a, txn=event.txn)
            pushq(action)

    # this function is called if the node recevies information about a transaction from its neighbours
    def txnRecv(self,event):
        if event.txn in self.txnReceived:
            return 
        self.txnReceived.add(event.txn)

        for a in self.peer:
            t = event.time + computeLatency(self,a,1)
            action = TxnRecv(time=t, sender=self.nid, receiver=a, txn=event.txn)
            pushq(action)

    # this function is called if node wants to mine a new block with given parent block
    def mineNewBlock(self, pblock, start_time):
        remaingTxn = self.txnReceived.difference(pblock.txnPool)
        txnToInclude = set(sample(remaingTxn, min(900,len(remaingTxn))))
        toBeDeleted = set()
        #print("debug p", pblock.balance)
        tmp_balance = pblock.balance.copy()
        for a in txnToInclude:
            if a.value > tmp_balance[a.sender.nid]:
                toBeDeleted.add(a)
            else:
                tmp_balance[a.sender.nid] -= a.value
                tmp_balance[a.receiver.nid] += a.value
        #print("debug", tmp_balance)
        txnToInclude = txnToInclude.difference(toBeDeleted)

        txnId = np.random.randint(0,2**31-1)
        coinBaseTxn = Transaction(tid=txnId, sender=-1, receiver=self, value=50)
        txnToInclude.add(coinBaseTxn)

        newBlockId = np.random.randint(0,2**31-1)
        newBlock = Block(bid=newBlockId, pbid=pblock, txnIncluded=txnToInclude, miner=self)
        assert newBlock.is_valid, "There is no point mining invalid blocks"
        mining_time = start_time + np.random.exponential(self.miningTime)
        newMiningEvent = BlockMined(time=mining_time, block=newBlock)
        pushq(newMiningEvent)

    # this function is called, if node receives a block from its peers
    # block is verified and if the block is without any errors then its is added to blockchain 
    # and then transmitted to neighbours 
    # If addition of that block creates a primary chain then mining is started over that block
    def verifyAndAddReceivedBlock(self,event):
        if event.block.bid in self.blockReceived:
            return 
        self.blockReceived.add(event.block.bid)

        if not event.block.is_valid: # we do not propogate invalid blocks
            return
        
        is_longest = self.blockchain.add_block(event.block, event.time)
        if is_longest:
            self.mineNewBlock(pblock=event.block, start_time=event.time)
        
        for a in self.peer:
            lat = computeLatency(i=self,j=a,m=100+len(event.block.txnIncluded))
            action = BlockRecv(time=event.time + lat, sender=self, receiver=a, block=event.block)
            pushq(action)
    
    # this function is called once the mining of a block is completed, 
    # If after mining the addition of block creates a primary chain then
    # the block is shared with neighbours and mining is continued otherwise 
    # node waits a block whose addition will, create primary chain
    def receiveSelfMinedBlock(self, event):
        self.blockReceived.add(event.block.bid)
        is_longest = self.blockchain.add_block(event.block, event.time)

        if is_longest:
            # print(f"{event.block}, Time:{pretty(event.time,10)}")
            for a in self.peer:
                lat = computeLatency(i=self, j=a, m=100+len(event.block.txnIncluded))
                action = BlockRecv(time=event.time+lat, sender=self, receiver=a, block=event.block)
                pushq(action)
            self.mineNewBlock(pblock=event.block, start_time=event.time)
